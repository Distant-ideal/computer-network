# 多线程

## 什么是线程

同一进程中的多条线程将共享该进程中的所有系统资源，如虚拟地址空间，文件描述符和信号处理等。但同一进程中的多个线程有各自的调用栈，自己的寄存器环境，自己的线程本地存储。一个进程可以有很多线程，每条线程并行执行不同的任务。

## 线程的优点

线程可以提高应用程序在多核环境下处理诸如文件I/O或者socket I/O等会产生堵塞的情况的表现性能。

在Unix系统中，一个进程包含很多东西，包括可执行程序以及一大堆的诸如文件描述符地址空间等资源。在很多情况下，完成相关任务的不同代码间需要交换数据。如果采用多进程的方式，那么通信就需要在用户空间和内核空间进行频繁的切换，开销很大。但是如果使用多线程的方式，因为可以使用共享的全局变量，所以线程间的通信（数据交换）变得非常高效。

## 线程的创建结束等待

### 创建线程pthread_create

线程创建函数包含四个变量

1.一个线程变量名，被创建线程的标识

2.线程的属性指针，缺省为NULL即可

3.被创建线程的程序代码

4.程序代码的参数

```c
pthread_create(&thrd1, NULL, (void *)&thread_function, (void *) &some_argument);
```

### 结束线程pthread_exit

线程结束调用实例:pthread_exit(void *retval); //retval用于存放线程结束的退出状态

### 线程等待pthread_join

pthread_creat调用成功以后，新线程和老线程谁先执行，谁后执行用户时不知道的，这一块取决与操作系统对线程的调度，如果我们需要等待指定线程结束，需要使用pthread_join函数，这个函数实际上类似与多进程编程中的waitpid。举个例子，一下假设A线程调用pthread_join试图去操作B线程，该函数将A线程阻塞，知道B线程退出后，A线程会手机B线程的返回码。该函数包含两个参数：

pthread_t th //th是要等待结束的线程的标识

void **thread_return //指针thread_return指向的位置存放的是终止线程的返回状态

调用实例:pthread_join(thrd1,NULL);

## 多线程的同步与互斥

### 方式一：锁

#### 在主线程中初始化锁为解锁状态

pthread_mutex_t mutex;

pthread_mutex_init(&mutex, NULL);

#### 在编译时初始化锁为解锁状态

锁初始化 pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

#### 访问对象时的加锁操作与解锁操作

加锁 pthread_mutex_lock(&mutex)

解锁 pthread_mutex_unlock(&mutex)

不加锁数据不同步

通过加锁，博癌症sharedi变量在进行变更的时候，只有一个线程能够取到，并在在该线程对其进行操作时，其他线程无法对其进行访问

1.锁保护的并不是我们的共享变量（或者说是共享内存），对于共享的内存而言，用户是无法直接对其保护的，因为那是物理内存，无法阻止其他程序的代码访问。事实上，锁之所以对关键区域进行了保护，在本例中，是因为所有线程都遵循了一个规则，那就是在进入关键区域钱加同一把锁，在退出关键区域钱释放同一把锁

2.我们从上述运行结果中可以看到，加锁是会带来额外的开销的，加锁的代码其运行速度，明显比不加锁的要慢一些，所以，在使用锁的时候，要合理，在不需要对关键区域进行保护的场景下，我们便不要画蛇添足，为其加锁了

### 方式二：信号量

锁有一个很明显的缺点，那就是它只有两种状态：锁定与不锁定

信号量本质上时一个非负数的整数计数器，它也被用来控制对公共资源的访问。当公共资源增加的时候，调用信号量增加函数sem_post()对其进行增加，当公共资源减少的时候，调用函数sem_wait()来减少信号量。其实，我们时可以把锁当做一个0-1信号量的

它们是在`/usr/include/semaphore.h`中进行定义的，信号量的数据结构为sem_t, 本质上，它是一个long型整数

#### 相关函数

在使用semaphore之前，我们需要先引入头文件`#include <semaphore.h>`

​	成功返回0，失败返回-1

​	参数

​	sem：执行信号量结构的一个指针

​	pshared：不是0的时候，该信号量在进程间共享，否则只能为当前进程的所有线程们共享

​	value：信号量的初始值

信号量减1操作，当sem=0的时候该函数会阻塞 int sem_wait(sem_t *sem);

​	成功返回0，失败返回-1

​	参数

​	sem：指向信号量的一个指针

信号量加1操作int sem_post(sem_t *sem);

​	参数与返回同上

销毁信号量int sem_destroy(sem_t *sem);

​	参数与返回同上

因为信号量机制的存在，所以代码在handle_data的时候，如果sem_wait(&sem)时，sem为0,那么代码会堵塞在sem_wait上面，从而避免了在stack中访问错误的index而使整个程序崩溃。

## 操作步骤

函数原型：int pthread_create(pthread_t *restrict tidp,const pthread_attr_t *restrict attr,void *(*start_rtn)(void),void *restrict arg);

返回值：若是成功奖励线程返回0，否则返回错误的编号。

形式参数：该函数的作用使得当前线程挂起，等待另一个线程返回才继续执行。也就是说当程序运行到这个地方时，程序会先停止，然后等线程id为thread的这个线程返回，然后程序才会断续执行。

线程挂起：该函数的作用是的当前线程挂起，等待另一个线程返回才继续执行。也就是说放程序运行到这个地方时，程序会先停止，然后等id为thread的这个线程返回，然后程序才会断续执行。

函数原型：int pthread_join([pthread_t thread, void **value_ptr);

参数说明如下：thread等待退出线程的线程号；value_ptr退出线程的返回值。

返回值：若成功，则返回0；若失败，则返回错误号。

线程退出

函数原型：void pthread_exit(void *rval_ptr);

获取当前进程id

函数原型：pthread_t pthread_self(void);

互斥锁

创建pthread_mutex_init；销毁[pthread_mutex_destroy；加锁pthread_mutex_lock；解锁pthread_mutex_unlock。

条件锁

创建pthread_cond_init；销毁pthread_cond_destroy；触发pthread_cond_signal；广播pthread_cond_broadcast；等待pthread_cond_wait。



 



